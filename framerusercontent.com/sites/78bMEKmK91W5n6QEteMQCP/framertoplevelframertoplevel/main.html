
        import * as React from "react"
        import * as ReactDOM from "react-dom/client"
        import * as Framer from "framer"
        

        const routes = {NYptFwJkI: {elements: {aENFTKjzY: "credits", AetI5MZsW: "1-hands-mush", afV05NWDQ: "03-trippy-b", AH3tiZJ41: "12-inches-4", AMeqh5cl4: "12-inches-integer-1", Cq2BowFKu: "header", Crn2pN7Xd: "03-trippy-c", dPGyOXufh: "12-inches-3", gOQPznUFh: "shoulder", GzKxOrCpB: "footer", HSo3leOTs: "fart-title", HU8fQFEQf: "money", JrMeIrMq7: "12-inches-2", JxzvF8yUW: "meet", K6BA4sd8Q: "buzz", KYgh_oueu: "12inches", MUpabZyGC: "12-inches-6", P4MjFmL90: "dollar-sign", pPaIImPJb: "2-mouth", QTZJxKcmi: "12-inches-1", s1RT1aLbU: "pepe-secret", SErN4xt2y: "toilett", tgzD5vErP: "trippyb", UGTOh9gwS: "fart", uhi4Avt6n: "trippy-c", UsHo0rhZw: "trippy-a", Uv1AuDehx: "12-inches-integer", XIZK1fxha: "12-inches-7", XMmszZC1T: "12-inches-5", ZJoAY1VS8: "03-trippy-a"}, page: Framer.lazy(() => import("/framerusercontent.com/modules/2iKHyugCvVC8PLA42cZR/TgKgts5jJ10nmc3xYf8L/NYptFwJkI.js")), path: "/"}, augiA20Il: {elements: {aOEW7apm9: "header", aQkHOexZTAb0lNGtfD: "2-mouth-1", aQkHOexZTCg77CrkYV: "12-inches-4-1", aQkHOexZTfrTxDIPA_: "12-inches-1-1", aQkHOexZTGseh0TJUi: "12-inches-6-1", aQkHOexZTHS0j_1jBh: "12-inches-3-1", aQkHOexZTJ3mnfut3w: "meet-1", aQkHOexZTk__OHprt1: "12-inches-5-1", aQkHOexZTKgQykzTU1: "toilett-1", aQkHOexZTlDiMdfbuW: "header-2", aQkHOexZTM1p_6OutU: "03-trippy-a-1", aQkHOexZTmRrdgVFwO: "03-trippy-b-1", aQkHOexZTNm2fdRRPk: "fart-1", aQkHOexZTOhpAK00jc: "12-inches-2-1", aQkHOexZTohrsNIjiT: "trippyb-1", aQkHOexZTooPjuxtOy: "12-inches-integer-2", aQkHOexZToROGlmjJK: "trippy-c-1", aQkHOexZTPQm5GP5qG: "12-inches-integer-3", aQkHOexZTpY2QD70Yj: "shoulder-1", aQkHOexZTrbWIZ9eoW: "03-trippy-c-1", aQkHOexZTScPM6KxyZ: "12inches-1", aQkHOexZTuaiusnjYD: "footer-1", aQkHOexZTVQUIY2RJB: "dollar-sign-1", aQkHOexZTVXHTkDD1V: "trippy-a-1", aQkHOexZTvyfpjtpBi: "1-hands-mush-1", aQkHOexZTxap6Q8aTT: "12-inches-7-1", aQkHOexZTxeLCFGEGQ: "money-1", aQkHOexZTyDBbht6JD: "credits-1", aQkHOexZTYHxqx9FQD: "buzz-1", aQkHOexZTyL4LNVFSw: "pepe-secret-1", aQkHOexZTZ5agWWqra: "fart-title-1", lL28r9MLUAb0lNGtfD: "2-mouth-2", lL28r9MLUCg77CrkYV: "12-inches-4-2", lL28r9MLUfrTxDIPA_: "12-inches-1-2", lL28r9MLUGseh0TJUi: "12-inches-6-2", lL28r9MLUHS0j_1jBh: "12-inches-3-2", lL28r9MLUJ3mnfut3w: "meet-2", lL28r9MLUk__OHprt1: "12-inches-5-2", lL28r9MLUKgQykzTU1: "toilett-2", lL28r9MLUlDiMdfbuW: "header-3", lL28r9MLUM1p_6OutU: "03-trippy-a-2", lL28r9MLUmRrdgVFwO: "03-trippy-b-2", lL28r9MLUNm2fdRRPk: "fart-2", lL28r9MLUOhpAK00jc: "12-inches-2-2", lL28r9MLUohrsNIjiT: "trippyb-2", lL28r9MLUooPjuxtOy: "12-inches-integer-4", lL28r9MLUoROGlmjJK: "trippy-c-2", lL28r9MLUPQm5GP5qG: "12-inches-integer-5", lL28r9MLUpY2QD70Yj: "shoulder-2", lL28r9MLUrbWIZ9eoW: "03-trippy-c-2", lL28r9MLUScPM6KxyZ: "12inches-2", lL28r9MLUuaiusnjYD: "footer-2", lL28r9MLUVQUIY2RJB: "dollar-sign-2", lL28r9MLUVXHTkDD1V: "trippy-a-2", lL28r9MLUvyfpjtpBi: "1-hands-mush-2", lL28r9MLUxap6Q8aTT: "12-inches-7-2", lL28r9MLUxeLCFGEGQ: "money-2", lL28r9MLUyDBbht6JD: "credits-2", lL28r9MLUYHxqx9FQD: "buzz-2", lL28r9MLUyL4LNVFSw: "pepe-secret-2", lL28r9MLUZ5agWWqra: "fart-title-2", uVPKcHrb1Ab0lNGtfD: "2-mouth", uVPKcHrb1Cg77CrkYV: "12-inches-4", uVPKcHrb1frTxDIPA_: "12-inches-1", uVPKcHrb1Gseh0TJUi: "12-inches-6", uVPKcHrb1HS0j_1jBh: "12-inches-3", uVPKcHrb1J3mnfut3w: "meet", uVPKcHrb1k__OHprt1: "12-inches-5", uVPKcHrb1KgQykzTU1: "toilett", uVPKcHrb1lDiMdfbuW: "header-1", uVPKcHrb1M1p_6OutU: "03-trippy-a", uVPKcHrb1mRrdgVFwO: "03-trippy-b", uVPKcHrb1Nm2fdRRPk: "fart", uVPKcHrb1OhpAK00jc: "12-inches-2", uVPKcHrb1ohrsNIjiT: "trippyb", uVPKcHrb1ooPjuxtOy: "12-inches-integer", uVPKcHrb1oROGlmjJK: "trippy-c", uVPKcHrb1PQm5GP5qG: "12-inches-integer-1", uVPKcHrb1pY2QD70Yj: "shoulder", uVPKcHrb1rbWIZ9eoW: "03-trippy-c", uVPKcHrb1ScPM6KxyZ: "12inches", uVPKcHrb1uaiusnjYD: "footer", uVPKcHrb1VQUIY2RJB: "dollar-sign", uVPKcHrb1VXHTkDD1V: "trippy-a", uVPKcHrb1vyfpjtpBi: "1-hands-mush", uVPKcHrb1xap6Q8aTT: "12-inches-7", uVPKcHrb1xeLCFGEGQ: "money", uVPKcHrb1yDBbht6JD: "credits", uVPKcHrb1YHxqx9FQD: "buzz", uVPKcHrb1yL4LNVFSw: "pepe-secret", uVPKcHrb1Z5agWWqra: "fart-title"}, page: Framer.lazy(() => import("/framerusercontent.com/modules/xoW8s9xq6VCLuNepS1ul/42evLpuPddCKQGtdqP7k/augiA20Il.js")), path: "/404"}}
        const locales = [{code: "en", id: "default", name: "English", slug: ""}]
        
        

        export async function getPageRoot({ routeId, pathVariables, localeId }) {
            // We don't want the initial render to immediately have to suspend.
            await routes[routeId].page.preload()

            const content = React.createElement(
                Framer.PageRoot,
                {
                    isWebsite: true,
                    routeId,
                    pathVariables,
                    routes,
                    collectionUtils: {},
                    framerSiteId: "d3fe69d6027356d0988876f2501dbd2c1b53da90291b1d7f67722330b0442b10",
                    notFoundPage: Framer.lazy(() => import("/framerusercontent.com/modules/xoW8s9xq6VCLuNepS1ul/42evLpuPddCKQGtdqP7k/augiA20Il.js")),
                    isReducedMotion: undefined,
                    localeId,
                    locales,
                    preserveQueryParams: undefined,
                    
                    
                }
            )

            const contentWithFeaturesContext = React.createElement(
                Framer.LibraryFeaturesProvider,
                {
                    children: content,
                    value: {codeBoundaries: false, editorBarMenu: false, enableAsyncURLUpdates: true, replaceNestedLinks: true, useGranularSuspense: true, wrapUpdatesInTransitions: true}
                }
            )

            const contentWithGracefullyDegradingErrorBoundary = React.createElement(Framer.GracefullyDegradingErrorBoundary, {
                children: contentWithFeaturesContext
            })

            
            const page = React.createElement(Framer.PageEffectsProvider, {
                children: contentWithGracefullyDegradingErrorBoundary,
                value: {routes: {}}
            })

            return page
        }

        const isBrowser = typeof document !== "undefined"
        if (isBrowser) {
            window.__framer_importFromPackage = (packageAndFilename, exportIdentifier) => () => {
                return React.createElement(Framer.ErrorPlaceholder, { error: 'Package component not supported: "' + exportIdentifier + '" in "' + packageAndFilename + '"' })
            }

            // A lot of libraries assume process.env.NODE_ENV is present in runtime/buildtime, so we are polyfilling it
            window.process = {
                ...window.process,
                env: {
                    ...(window.process ? window.process.env: undefined),
                    NODE_ENV: "production"
                }
            }

            window.__framer_events = window.__framer_events || []

            // Fallback support for stack gaps
            Framer.installFlexboxGapWorkaroundIfNeeded()

            const container = document.getElementById("main")
            // We know that #main is parsed before this script, so we don't need to wait for DOMContentLoaded or similar events.
            if ("framerHydrateV2" in container.dataset) main(true, container)
            else main(false, container)
        }

        function track() {
            if (!isBrowser) return
            window.__framer_events.push(arguments)
        }

        async function main(shouldHydrate, container) {
            function handleError(error, errorInfo, recoverable = true) {
                if (error.caught || window.__framer_hadFatalError) return // we already logged it

                const componentStack = errorInfo?.componentStack
                if (recoverable) {
                    console.warn("Recoverable error during hydration. Please check any custom code or code overrides to fix server/client mismatches:\n", error, componentStack)
                    // we only want to collect 1%, because this can be quite noisy (floods the data pipeline)
                    if (Math.random() > 0.01) return
                } else {
                    console.error("Fatal crash during hydration. If you are the author of this website, please report this issue to the Framer team via https://www.framer.community/")
                }
                track(recoverable ? "published_site_load_recoverable_error" : "published_site_load_error", {
                    message: String(error),
                    componentStack, // componentStack is more useful
                    stack: componentStack ? undefined : error instanceof Error && typeof error.stack === "string" ? error.stack : null,
                })
            }

            try {
                let routeId, localeId, pathVariables, breakpoints
                if (shouldHydrate) {
                    const routeData = JSON.parse(container.dataset.framerHydrateV2)
                    routeId = routeData.routeId
                    localeId = routeData.localeId
                    pathVariables = routeData.pathVariables
                    breakpoints = routeData.breakpoints
                } else {
                    const routeData = Framer.inferInitialRouteFromPath(routes, decodeURIComponent(location.pathname), true, locales)
                    routeId = routeData.routeId
                    localeId = routeData.localeId
                    pathVariables = routeData.pathVariables
                }

                const page = await getPageRoot({ routeId, localeId, pathVariables })
                if (shouldHydrate) {
                    

                    Framer.withPerformanceMarks("framer-rewrite-breakpoints", () => {
                        Framer.removeHiddenBreakpointLayersV2(breakpoints)
                        window.__framer_onRewriteBreakpoints?.(breakpoints)
                    })

                    

                    const startTransition = React.startTransition
                    startTransition(() => {
                        Framer.markHydrationStart()
                        Framer.setInitialHydrationState()
                        if (true) Framer.turnOffReactEventHandling()
                        ReactDOM.hydrateRoot(container, page, { onRecoverableError: handleError })
                    })
                } else {
                    
                    ReactDOM.createRoot(container, { onRecoverableError: handleError }).render(page)
                }
            } catch (error) {
                handleError(error, undefined, false)
                throw error
            }
        }

        

        
    